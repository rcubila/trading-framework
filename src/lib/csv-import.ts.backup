import { supabase } from './supabase';
import type { Database } from './supabase-types';
import type { Trade } from '../types/trade';

interface ImportResult {
  trades: Trade[];
  errors: ImportError[];
}

interface ImportError {
  row: number;
  message: string;
}

// UUID v4 generator
const uuidv4 = (): string => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};

// Helper function to validate numbers
const validateNumber = (value: string, fieldName: string): number => {
  // Remove currency symbols, commas, and any quotes
  const cleanValue = value.replace(/[$,'"]/g, '');
  
  // Handle European number format (replace , with .)
  const normalizedValue = cleanValue.includes(',') ? 
    cleanValue.replace(',', '.') : cleanValue;
  
  const num = parseFloat(normalizedValue);
  if (isNaN(num)) {
    throw new Error(`Invalid ${fieldName}: ${value}. Must be a valid number.`);
  }
  return num;
};

// Helper function to validate dates
const validateDate = (value: string, fieldName: string): string => {
  // If value is empty, invalid, or epoch, use current date
  if (!value || value.trim() === '' || value === '1970-01-01 00:00' || value.includes('1970-01-01')) {
    return new Date().toISOString();
  }

  // Remove any quotes
  const cleanValue = value.replace(/['"]/g, '').trim();
  
  // Try parsing different date formats
  let date: Date | null = null;
  
  // Try DD/MM/YY HH:mm format (European)
  if (cleanValue.match(/^\d{2}\/\d{2}\/\d{2}\s+\d{2}:\d{2}$/)) {
    const [datePart, timePart] = cleanValue.split(' ');
    const [day, month, year] = datePart.split('/');
    const [hour, minute] = timePart.split(':');
    // Assume 20xx for two-digit years
    const fullYear = parseInt(year) + 2000;
    date = new Date(fullYear, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
  }
  // Try DD.MM.YY HH:mm format (European)
  else if (cleanValue.match(/^\d{2}\.\d{2}\.\d{2}\s+\d{2}:\d{2}$/)) {
    const [datePart, timePart] = cleanValue.split(' ');
    const [day, month, year] = datePart.split('.');
    const [hour, minute] = timePart.split(':');
    const fullYear = parseInt(year) + 2000;
    date = new Date(fullYear, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
  }
  // Try DD/MM/YYYY format (European)
  else if (cleanValue.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
    const [day, month, year] = cleanValue.split('/');
    date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  }
  // Try DD.MM.YYYY format (European)
  else if (cleanValue.match(/^\d{2}\.\d{2}\.\d{4}$/)) {
    const [day, month, year] = cleanValue.split('.');
    date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  }
  // Try standard ISO format and other common formats
  else {
    date = new Date(cleanValue);
  }

  if (!date || isNaN(date.getTime())) {
    // If date is invalid, use current date
    return new Date().toISOString();
  }

  // Validate that the date is reasonable (not too far in the past or future)
  const now = new Date();
  const fiveYearsAgo = new Date();
  fiveYearsAgo.setFullYear(now.getFullYear() - 5);
  const fiveYearsFromNow = new Date();
  fiveYearsFromNow.setFullYear(now.getFullYear() + 5);

  if (date < fiveYearsAgo || date > fiveYearsFromNow) {
    // If date is outside range, use current date
    return new Date().toISOString();
  }

  return date.toISOString();
};

// Helper function to find matching column
const findMatchingColumn = (headers: string[], possibleNames: string[]): string | undefined => {
  return headers.find(header => 
    possibleNames.some(name => 
      header.toLowerCase().replace(/[^a-z0-9]/g, '') === name.toLowerCase().replace(/[^a-z0-9]/g, '')
    )
  );
};

// Helper function to detect column type
const detectColumnType = (headers: string[], values: string[][]): { [key: string]: string } => {
  const columnTypes: { [key: string]: string } = {};
  
  headers.forEach((header, index) => {
    // Get all non-empty values for this column
    const columnValues = values.map(row => row[index]).filter(val => val && val.trim());
    if (columnValues.length === 0) return;

    // Check for market patterns
    const marketPattern = /(stocks?|crypto|forex|futures|equities|etfs?)/i;
    const isMarketColumn = columnValues.some(val => marketPattern.test(val));
    if (isMarketColumn) {
      columnTypes[header] = 'market';
      return;
    }

    // Check for date patterns
    const datePattern = /^\d{2}[-.]\d{2}[-.]\d{2}|\d{4}-\d{2}-\d{2}|^\d{2}:\d{2}|\d{2}[-.]\d{2}[-.]\d{2}\s+\d{2}:\d{2}/;
    const hasDateFormat = columnValues.some(val => datePattern.test(val));
    if (hasDateFormat) {
      columnTypes[header] = 'date';
      return;
    }

    // Check for price/number patterns
    const pricePattern = /^[\$£€]?\d+\.?\d*$/;
    const isPriceColumn = columnValues.some(val => pricePattern.test(val.replace(/,/g, '')));
    if (isPriceColumn) {
      columnTypes[header] = 'price';
      return;
    }

    // Check for volume/quantity patterns
    const isVolumeColumn = columnValues.some(val => {
      const cleanValue = val.replace(/,/g, '');
      return !isNaN(parseFloat(cleanValue)) && parseFloat(cleanValue) > 0;
    });
    if (isVolumeColumn && (
      header.toLowerCase().includes('volume') || 
      header.toLowerCase().includes('size') || 
      header.toLowerCase().includes('quantity') || 
      header.toLowerCase().includes('amount')
    )) {
      columnTypes[header] = 'volume';
      return;
    }

    // Check for action/type patterns
    const actionPattern = /(buy|sell|long|short)/i;
    const isActionColumn = columnValues.some(val => actionPattern.test(val));
    if (isActionColumn) {
      columnTypes[header] = 'action';
      return;
    }

    // Check for symbol patterns
    const symbolPattern = /^[A-Z.]{1,10}$/;
    const isSymbolColumn = columnValues.some(val => symbolPattern.test(val.toUpperCase()));
    if (isSymbolColumn) {
      columnTypes[header] = 'symbol';
      return;
    }
  });

  return columnTypes;
};

// Helper function to determine market and category
const determineMarketAndCategory = (symbol: string, market?: string): { market: string; market_category: 'Equities' | 'Crypto' | 'Forex' | 'Futures' | 'Other' } => {
  // First check for futures symbols (including variations)
  const futuresSymbols = [
    'ES', 'NQ', 'YM', 'RTY', 'CL', 'GC', 'SI', '6E', 'ZB', 'ZN',  // CME futures
    'GER40', 'DE40', 'DAX', '.USTEC', 'NAS100',  // Index futures
    'FGBL', 'FGBM', 'FGBS', 'FGBX',  // Euro-Bund futures
    'STOXX50E', 'ESTX50',  // Euro Stoxx 50
    'FTSE', 'UK100',  // FTSE 100
    'NIKKEI', 'NK225'  // Nikkei 225
  ];
  
  // Check for exact match or if symbol contains any of the futures symbols
  if (futuresSymbols.some(fs => symbol === fs || symbol.includes(fs))) {
    return { market: 'Futures', market_category: 'Futures' };
  }

  // If market is provided, use it to determine category
  if (market) {
    const normalizedMarket = market.toLowerCase();
    if (normalizedMarket.includes('future') || 
        normalizedMarket.includes('eurex') || 
        normalizedMarket.includes('cme') || 
        normalizedMarket.includes('ice')) {
      return { market: 'Futures', market_category: 'Futures' };
    }
    if (normalizedMarket.includes('stock') || normalizedMarket.includes('equity') || normalizedMarket.includes('etf')) {
      return { market: 'Stocks', market_category: 'Equities' };
    }
    if (normalizedMarket.includes('crypto') || normalizedMarket.includes('binance')) {
      return { market: 'Spot Crypto', market_category: 'Crypto' };
    }
    if (normalizedMarket.includes('forex') || normalizedMarket.includes('fx')) {
      return { market: 'Spot Forex', market_category: 'Forex' };
    }
  }

  // Try to determine from symbol pattern
  if (symbol.length === 6 && /^[A-Z]{6}$/.test(symbol)) {
    return { market: 'Spot Forex', market_category: 'Forex' };
  }
  if (symbol.includes('USDT') || symbol.includes('BTC') || symbol.includes('ETH')) {
    return { market: 'Spot Crypto', market_category: 'Crypto' };
  }
  
  // Default to Stocks/Equities
  return { market: 'Stocks', market_category: 'Equities' };
};

export const importTradesFromCSV = async (csvContent: string): Promise<ImportResult> => {
  const result: ImportResult = {
    trades: [],
    errors: []
  };

  try {
    // Get current user
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('No user logged in');
    }

    // Parse CSV content
    const lines = csvContent.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
      throw new Error('CSV file must contain at least a header row and one data row');
    }

    const headers = lines[0].split(',').map(h => h.trim());
    const rows = lines.slice(1);

    // Process each row
    for (let i = 0; i < rows.length; i++) {
      try {
        const row = rows[i].split(',').map(cell => cell.trim());
        const trade: Partial<Trade> = {
          user_id: user.id,
          market: row[headers.indexOf('Market')] || 'Stocks',
          market_category: row[headers.indexOf('Category')] || 'Equities',
          symbol: row[headers.indexOf('Symbol')]?.toUpperCase(),
          type: row[headers.indexOf('Action')]?.toLowerCase().includes('buy') ? 'Long' : 'Short',
          status: 'Closed',
          entry_price: parseFloat(row[headers.indexOf('Open Price')] || '0'),
          exit_price: parseFloat(row[headers.indexOf('Close Price')] || '0'),
          quantity: parseInt(row[headers.indexOf('Volume')] || '0'),
          entry_date: new Date(row[headers.indexOf('Open')] || '').toISOString(),
          exit_date: new Date(row[headers.indexOf('Close')] || '').toISOString(),
          pnl: parseFloat(row[headers.indexOf('Profit')] || '0'),
          pnl_percentage: 0, // Calculate this based on entry/exit prices
          strategy: row[headers.indexOf('Strategy')] || undefined,
          tags: row[headers.indexOf('Tags')]?.split(';').map(t => t.trim()) || [],
          notes: row[headers.indexOf('Notes')] || undefined
        };

        // Validate required fields
        if (!trade.symbol || !trade.entry_price || !trade.quantity || !trade.entry_date) {
          result.errors.push({
            row: i + 2,
            message: 'Missing required fields (Symbol, Open Price, Volume, Open Date)'
          });
          continue;
        }

        // Calculate PnL percentage if not provided
        if (trade.entry_price && trade.exit_price) {
          const pnlAmount = trade.exit_price - trade.entry_price;
          trade.pnl_percentage = (pnlAmount / trade.entry_price) * 100;
        }

        result.trades.push(trade as Trade);
      } catch (error) {
        result.errors.push({
          row: i + 2,
          message: `Error processing row: ${error instanceof Error ? error.message : 'Unknown error'}`
        });
      }
    }

    return result;
  } catch (error) {
    console.error('Import error:', error);
    throw error;
  }
}; 